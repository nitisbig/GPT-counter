function monthAddCalendar(dt: DateTime, months = 1) { // Calendar add: preserves local time and handles 28–31 day months return dt.plus({ months }); }

function durationBreakdown(ms: number) { const days = Math.floor(ms / MS_PER_DAY); const rem1 = ms - days * MS_PER_DAY; const hours = Math.floor(rem1 / MS_PER_HOUR); const rem2 = rem1 - hours * MS_PER_HOUR; const minutes = Math.floor(rem2 / MS_PER_MIN); const seconds = Math.floor((rem2 - minutes * MS_PER_MIN) / 1000); return { days, hours, minutes, seconds }; }

function humanRel(dt: DateTime, base: DateTime) { const diff = dt.diff(base, ["days", "hours", "minutes"]).toObject(); const parts: string[] = []; if ((diff.days ?? 0) !== 0) parts.push(${Math.trunc(Math.abs(diff.days ?? 0))}d); if ((diff.hours ?? 0) !== 0) parts.push(${Math.trunc(Math.abs(diff.hours ?? 0))}h); if (parts.length < 2) parts.push(${Math.trunc(Math.abs(diff.minutes ?? 0))}m); const tense = dt >= base ? "from now" : "ago"; return ${parts.join(" ")} ${tense}; }

function uid() { return Math.random().toString(36).slice(2); }

// Persist/restore JSON to localStorage function loadState<T>(key: string, fallback: T): T { try { const raw = localStorage.getItem(key); if (!raw) return fallback; return { ...fallback, ...JSON.parse(raw) } as T; } catch { return fallback; } } function saveState<T>(key: string, val: T) { try { localStorage.setItem(key, JSON.stringify(val)); } catch {} }

// Roll input cycle to the window that contains now. function rollCycleToNow(cycle: SubscriptionCycle, now: DateTime): { start: DateTime; end: DateTime; rolled: boolean } { let start = inZone(cycle.startISO, cycle.timezone); let end = inZone(cycle.endISO, cycle.timezone); let rolled = false;

if (now < start) { // If user set a start in the future, keep as-is (pre-cycle state) return { start, end, rolled }; }

// Move forward by calendar months until now < end while (now >= end) { start = end; end = monthAddCalendar(end, 1); rolled = true; } return { start, end, rolled }; }

// Compute milestones function milestoneTimes(start: DateTime, end: DateTime) { const totalMs = end.toMillis() - start.toMillis(); const halfway = start.plus({ milliseconds: totalMs / 2 }); const threeDays = end.minus({ days: 3 }); const lastDay = end.minus({ hours: 24 }); const renewal = end; return { halfway, threeDays, lastDay, renewal }; }

// .ics export (simple, TZ-aware) function generateICS(start: DateTime, end: DateTime, zone: string) { const { halfway, threeDays, lastDay, renewal } = milestoneTimes(start, end); const nowUTC = DateTime.now().toUTC(); const dtstamp = nowUTC.toFormat("yyyyLLdd'T'HHmmss'Z'"); const wrap = (dt: DateTime) => DTSTART;TZID=${zone}:${dt.toFormat("yyyyLLdd'T'HHmm")}; const events = [ { sum: "ChatGPT Plus: Halfway point", dt: halfway }, { sum: "ChatGPT Plus: 3 days left", dt: threeDays }, { sum: "ChatGPT Plus: 24 hours left", dt: lastDay }, { sum: "ChatGPT Plus: Renewal", dt: renewal.minus({ minutes: 5 }) }, ]; const vevents = events.map((e) => [ "BEGIN:VEVENT", UID:${uid()}@gptdeadline, DTSTAMP:${dtstamp}, wrap(e.dt), SUMMARY:${e.sum}, "END:VEVENT", ].join("\n")).join("\n");

// Minimal VCALENDAR; VTIMEZONE omitted for brevity (many calendars resolve IANA TZIDs) const ics = [ "BEGIN:VCALENDAR", "VERSION:2.0", "CALSCALE:GREGORIAN", "PRODID:-//GPTDeadline//EN", vevents, "END:VCALENDAR", ].join("\n"); return ics; }

// Inline Service Worker to cache the current page for offline async function registerInlineSW() { if (typeof navigator === "undefined" || !("serviceWorker" in navigator)) return; try { const swCode = const CACHE = 'gpt-deadline-v1'; self.addEventListener('install', (e) => { e.waitUntil((async () => { const cache = await caches.open(CACHE); await cache.addAll([self.registration.scope]); })()); }); self.addEventListener('fetch', (e) => { e.respondWith((async () => { const cached = await caches.match(e.request); if (cached) return cached; try { return await fetch(e.request); } catch (err) { return new Response('Offline', { status: 200, headers: { 'Content-Type': 'text/plain' } }); } })()); });; const blob = new Blob([swCode], { type: "text/javascript" }); const url = URL.createObjectURL(blob); await navigator.serviceWorker.register(url); } catch {} }

// ------------------------ Component UI --------------------------- //

const TIPS = [ "Try Deep Research for a complex topic you’ve been postponing.", "Audit your best prompts; turn them into reusable templates.", "Use voice + screen share to troubleshoot a workflow quickly.", "Batch tasks: draft 5 emails, then refine in one go.", "Set up automations for weekly summaries and reminders.", "Keep a ‘Wins’ doc—log outputs you shipped thanks to Plus.", ];

function useRotatingTip(intervalMs = 8000) { const [i, setI] = useState(0); useEffect(() => { const id = setInterval(() => setI((p) => (p + 1) % TIPS.length), intervalMs); return () => clearInterval(id); }, [intervalMs]); return TIPS[i]; }

function useTheme(theme: Theme) { useEffect(() => { const root = document.documentElement; const sysDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; const isDark = theme === 'dark' || (theme === 'system' && sysDark); root.classList.toggle('dark', isDark); }, [theme]); }

function useNowTick(qaMode: boolean, qaNowISO?: string) { const [now, setNow] = useState(() => qaMode && qaNowISO ? inZone(qaNowISO) : DateTime.now().setZone(DEFAULT_ZONE)); useEffect(() => { let frame = 0; const tick = () => setNow((prev) => qaMode ? prev.plus({ seconds: 1 }) : DateTime.now().setZone(DEFAULT_ZONE)); const id = setInterval(tick, 1000); return () => { cancelAnimationFrame(frame); clearInterval(id); }; }, [qaMode]); useEffect(() => { if (qaMode && qaNowISO) setNow(inZone(qaNowISO)); }, [qaMode, qaNowISO]); return now; }

function useReminders( enabled: SubscriptionCycle["reminders"], start: DateTime, end: DateTime, ) { const timers = useRef<{ [K in ReminderKeys]?: number }>({}); const [toasts, setToasts] = useState<{ id: string; title: string; body: string }[]>([]);

useEffect(() => { // Clear previous timeouts Object.values(timers.current).forEach((id) => id && clearTimeout(id)); timers.current = {};

const schedule = async (key: ReminderKeys, at: DateTime, title: string, body: string) => {
  const nowRef = DateTime.now().setZone(DEFAULT_ZONE);
  const delay = at.toMillis() - nowRef.toMillis();
  if (delay <= 0 || !enabled[key]) return;
  // Try Notification API
  const notify = () => {
    if ("Notification" in window) {
      if (Notification.permission === "granted") {
        new Notification(title, { body });
      }
    }
    // In-app toast fallback
    const tid = uid();
    setToasts((list) => [{ id: tid, title, body }, ...list].slice(0, 4));
    window.setTimeout(() => {
      setToasts((list) => list.filter((t) => t.id !== tid));
    }, 7000);
  };
  if ("Notification" in window && Notification.permission === "default") {
    try { await Notification.requestPermission(); } catch {}
  }
  timers.current[key] = window.setTimeout(notify, delay);
};

const { halfway, threeDays, lastDay, renewal } = milestoneTimes(start, end);
schedule("halfway", halfway, "Halfway point", "You’re halfway through this cycle. Plan a high-value session.");
schedule("threeDays", threeDays, "3 days left", "Three days left—queue the tasks you want done.");
schedule("lastDay", lastDay, "24 hours left", "Last day of this cycle. Ship something today.");
schedule("renewal", renewal.minus({ minutes: 5 }), "Renewal soon", "Your plan renews in 5 minutes.");

return () => {
  Object.values(timers.current).forEach((id) => id && clearTimeout(id));
  timers.current = {};
};

}, [enabled, start.toMillis(), end.toMillis()]);

const snooze = (minutes = 60) => { const title = "Snoozed reminder"; const body = I'll remind you again in ${minutes} minutes.; const id = window.setTimeout(() => { if ("Notification" in window && Notification.permission === "granted") { new Notification("Reminder", { body: "This is your snoozed reminder." }); } setToasts((list) => [{ id: uid(), title: "Reminder", body: "Snooze time is up." }, ...list].slice(0, 4)); }, minutes * MS_PER_MIN); const tid = uid(); setToasts((list) => [{ id: tid, title, body }, ...list].slice(0, 4)); window.setTimeout(() => { setToasts((list) => list.filter((t) => t.id !== tid)); }, 7000); return id; };

const dismissToast = (id: string) => setToasts((list) => list.filter((t) => t.id !== id));

return { toasts, snooze, dismissToast }; }

// Progress ring component function ProgressRing({ progress, label, size = 220 }: { progress: number; label: string; size?: number }) { const stroke = 14; const r = (size - stroke) / 2; const c = 2 * Math.PI * r; const clamped = clamp(progress, 0, 1); const dash = c * clamped; const offset = c - dash; return ( <div className="relative inline-block" aria-label="Subscription progress" role="img" aria-valuemin={0} aria-valuemax={100} aria-valuenow={Math.round(clamped * 100)}> <svg width={size} height={size} className="block"> <circle cx={size / 2} cy={size / 2} r={r} strokeWidth={stroke} className="text-gray-200 dark:text-gray-800" stroke="currentColor" fill="none" /> <circle cx={size / 2} cy={size / 2} r={r} strokeWidth={stroke} strokeLinecap="round" className="text-blue-500" strokeDasharray={${dash} ${c}} strokeDashoffset={offset} stroke="currentColor" fill="none" transform={rotate(-90 ${size / 2} ${size / 2})} /> </svg> <div className="absolute inset-0 flex flex-col items-center justify-center"> <div className="text-4xl font-semibold" aria-live="polite">{label}</div> <div className="text-sm text-gray-500">{pct(1 - clamped)} left</div> </div> </div> ); }

// Linear timeline function Timeline({ start, now, end }: { start: DateTime; now: DateTime; end: DateTime }) { const total = end.toMillis() - start.toMillis(); const elapsed = clamp(now.toMillis() - start.toMillis(), 0, total); const pctNow = (elapsed / total) * 100; return ( <div className="w-full"> <div className="h-2 w-full rounded-full bg-gray-200 dark:bg-gray-800 relative overflow-hidden"> <div className="absolute inset-y-0 left-0 bg-blue-500" style={{ width: ${pctNow}% }} /> {/* markers */} <div className="absolute -top-1 left-0 h-4 w-0.5 bg-gray-400" aria-label="start marker" /> <div className="absolute -top-1 right-0 h-4 w-0.5 bg-gray-400" aria-label="end marker" /> <div className="absolute -top-1" style={{ left: calc(${pctNow}% - 1px) }}> <div className="h-4 w-0.5 bg-blue-600" aria-label="now marker" /> </div> </div> <div className="mt-2 flex justify-between text-xs text-gray-600 dark:text-gray-300"> <span>Start</span> <span>Today</span> <span>End</span> </div> </div> ); }

// Calendar heat-strip for each day’s % elapsed function CalendarStrip({ start, now, end }: { start: DateTime; now: DateTime; end: DateTime }) { const days: { date: DateTime; fill: number }[] = []; let cursor = start.startOf("day"); const endDay = end.startOf("day"); while (cursor <= endDay) { const dayStart = DateTime.max(cursor, start); const dayEnd = DateTime.min(cursor.plus({ days: 1 }), end); const denom = Math.max(1, dayEnd.toMillis() - dayStart.toMillis()); const upto = DateTime.min(dayEnd, now); const fill = clamp((upto.toMillis() - dayStart.toMillis()) / denom, 0, 1); days.push({ date: cursor, fill }); cursor = cursor.plus({ days: 1 }); } return ( <div className="flex gap-1 flex-wrap" aria-label="Calendar progress strip"> {days.map((d) => ( <div key={d.date.toISODate()} className="w-6 h-8 rounded bg-gray-200 dark:bg-gray-800 overflow-hidden" title={${d.date.toFormat("LLL d")}: ${(d.fill*100).toFixed(0)}%}> <div className="h-full bg-blue-500" style={{ height: ${d.fill * 100}% }} /> </div> ))} </div> ); }

// --------------------------- Main App ---------------------------- //

export default function GPTDeadlineApp() { // Load persisted cycle const [cycle, setCycle] = useState<SubscriptionCycle>(() => loadState("gpt-deadline:cycle", DEFAULT_CYCLE)); const [detailsOpen, setDetailsOpen] = useState(false); const [tipsOpen, setTipsOpen] = useState(false); const [settingsOpen, setSettingsOpen] = useState(false); const [qaMode, setQaMode] = useState(false); const [qaNowISO, setQaNowISO] = useState<string | undefined>(undefined); const theme = cycle.theme; useTheme(theme);

// Ensure Luxon default zone aligns (defensive) useEffect(() => { Settings.defaultZone = cycle.timezone; }, [cycle.timezone]);

// Service worker (inline) for offline support useEffect(() => { registerInlineSW(); }, []);

// Live "now" clock (1s) const now = useNowTick(qaMode, qaNowISO);

// Compute the active window for this cycle (roll over if passed end) const { start, end, rolled } = useMemo(() => rollCycleToNow(cycle, now), [cycle, now.toMillis()]);

const totalMs = end.toMillis() - start.toMillis(); const elapsedMs = clamp(now.toMillis() - start.toMillis(), 0, totalMs); const remainingMs = clamp(end.toMillis() - now.toMillis(), 0, totalMs); const progress = elapsedMs / totalMs; const { days, hours, minutes, seconds } = durationBreakdown(remainingMs);

// Rotating tip const tip = useRotatingTip();

// Reminders const { toasts, snooze, dismissToast } = useReminders(cycle.reminders, start, end);

// Persist cycle to localStorage useEffect(() => { saveState("gpt-deadline:cycle", cycle); }, [cycle]);

// Formatters const keyDates = useMemo(() => ({ startLabel: fmtDate(start, cycle.hourFormat), endLabel: fmtDate(end, cycle.hourFormat), }), [start.toMillis(), end.toMillis(), cycle.hourFormat]);

const milestones = useMemo(() => { const m = milestoneTimes(start, end); return [ { key: "halfway" as const, label: "Halfway point", at: m.halfway }, { key: "threeDays" as const, label: "3 days left", at: m.threeDays }, { key: "lastDay" as const, label: "24 hours left", at: m.lastDay }, { key: "renewal" as const, label: "Renewal", at: m.renewal }, ]; }, [start.toMillis(), end.toMillis()]);

const renewedState = now >= end;

// ---------------------- Handlers / Mutations --------------------- // const updateReminder = (k: ReminderKeys, v: boolean) => setCycle((c) => ({ ...c, reminders: { ...c.reminders, [k]: v } })); const toggleTheme = (t: Theme) => setCycle((c) => ({ ...c, theme: t })); const toggleHourFmt = (f: HourFormat) => setCycle((c) => ({ ...c, hourFormat: f }));

const onEditDates = (newStartLocal: string, newEndLocal: string) => { const s = fromLocalInputValue(newStartLocal, cycle.timezone); const e = fromLocalInputValue(newEndLocal, cycle.timezone); if (!s.isValid || !e.isValid || e <= s) return alert("Please provide valid start/end with end after start."); setCycle((c) => ({ ...c, startISO: s.toISO(), endISO: e.toISO() })); };

const onExportICS = () => { const ics = generateICS(start, end, cycle.timezone); const blob = new Blob([ics], { type: "text/calendar;charset=utf-8" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = gpt-deadline-${start.toFormat('yyyyLLdd')}-${end.toFormat('yyyyLLdd')}.ics; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); };

const onResetDefaults = () => setCycle(DEFAULT_CYCLE);

// ----------------------------- UI ------------------------------- //

return ( <div className="min-h-screen bg-white text-gray-900 dark:bg-neutral-950 dark:text-neutral-100 transition-colors duration-200"> {/* Header */} <header className="px-4 py-3 flex items-center justify-between border-b border-black/5 dark:border-white/10 sticky top-0 backdrop-blur supports-[backdrop-filter]:bg-white/60 dark:supports-[backdrop-filter]:bg-neutral-950/60"> <div className="flex items-center gap-2"> <span className="text-xl font-semibold">GPT deadline</span> <span className="text-xs px-2 py-0.5 rounded-full bg-blue-50 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300">{cycle.plan}</span> </div> <div className="flex items-center gap-2"> <button className="px-3 py-1.5 rounded-lg bg-gray-100 dark:bg-white/10 hover:bg-gray-200 dark:hover:bg-white/20 text-sm" onClick={() => setSettingsOpen(true)} aria-label="Open settings">Settings</button> </div> </header>

{/* Main */}
  <main className="mx-auto max-w-5xl p-4 grid gap-4 md:grid-cols-[1.2fr_1fr]">
    {/* Left: Hero ring + timeline */}
    <motion.section layout className="rounded-2xl p-4 md:p-6 bg-white/70 dark:bg-white/5 shadow-sm ring-1 ring-black/5 dark:ring-white/10">
      <div className="flex flex-col items-center gap-4">
        <ProgressRing progress={progress} label={`${days}d`} />
        <div className="flex items-center gap-2 text-lg" aria-live="polite" aria-label="Countdown timer">
          <span className="tabular-nums">{days}d</span>
          <span>•</span>
          <span className="tabular-nums">{hours}h</span>
          <span>•</span>
          <span className="tabular-nums">{minutes}m</span>
          <span>•</span>
          <span className="tabular-nums">{seconds}s</span>
        </div>
        <Timeline start={start} now={now} en


          
